"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var big_1 = require("./big");
function operate(x, y, operator) {
    try {
        return Number(new big_1.default(x)[operator](new big_1.default(y)).toString());
    }
    catch (e) {
        return NaN;
    }
}
var prototype = Number.prototype;
// 乘法
prototype.mul = function (value) {
    return operate(this, value, 'mul');
};
// 除法
prototype.div = function (value) {
    // fix Infinity and NaN
    if (value === 0) {
        return this / value;
    }
    return operate(this, value, 'div');
};
// 减法
prototype.minus = function (value) {
    return operate(this, value, 'minus');
};
// 加法
prototype.plus = function (value) {
    return operate(this, value, 'plus');
};
/**
 * 保留小数位数
 * @param value 小数位数
 * @param truncate 不四舍五入，默认为false，四舍五入
 * @returns 字符串
 */
prototype.toFixed2 = function (value, truncate) {
    if (value === void 0) { value = 0; }
    if (truncate === void 0) { truncate = false; }
    if (isNaN(value)) {
        value = 0;
    }
    try {
        // 长度必须大于等于0
        if (truncate && value >= 0) {
            var s = this.toString().split('.');
            var f = s[1];
            if (f && f.length >= value) {
                f = f.substr(0, value);
                return s[0] + (f.length ? '.' + f : '');
            }
        }
        return new big_1.default(this).toFixed(value);
    }
    catch (e) {
        // the best way is throw error same as Number toFixed,
        // but for fault tolerance return '' is more safy. other sheer libary use the same way.
        return '';
    }
};
