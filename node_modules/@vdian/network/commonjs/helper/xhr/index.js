"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var serialize_1 = require("../serialize");
var util_1 = require("../../util");
var GET_METHOD = 'GET';
var JSON_RESPONSE_TYPE = 'json';
function normalizeStatus(status, _a) {
    var url = _a.url;
    var xhrSuccessStatus = {
        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    };
    // File protocol always yields status code 0, assume 200
    if (status === 0 && url.indexOf('file:') === 0) {
        return 200;
    }
    return xhrSuccessStatus[status] || status;
}
function normalizeUrl(url, _a) {
    var method = _a.method, cache = _a.cache, data = _a.data;
    // append params if method is get
    if (method === GET_METHOD) {
        url = serialize_1.appendParams(url, data);
        // append _=times if no cache
        if (!cache) {
            url = serialize_1.appendParams(url, {
                _: Date.now()
            });
        }
    }
    return url;
}
function setWithCredentials(request, _a) {
    var withCredentials = _a.withCredentials;
    if (withCredentials) {
        request.withCredentials = true;
    }
}
function setResponseType(request, _a) {
    var responseType = _a.responseType;
    if (responseType) {
        // try set responseType
        try {
            request.responseType = responseType;
        }
        catch (e) {
            // will not throw error if not support responseType in some browser (锥子T1)
        }
    }
}
function setRequestHeader(request, _a) {
    var headers = _a.headers, method = _a.method, data = _a.data;
    if (!util.isObject(headers)) {
        return;
    }
    for (var name_1 in headers) {
        if (headers.hasOwnProperty(name_1) && !util.isUndef(headers[name_1])) {
            // if header name is content-type
            if (name_1.toLowerCase() === 'content-type') {
                // remove content-type if method is get or data is FormData
                // FormData: let browser set it
                // get method has no body, set Content-Type is unnecessary
                if (method === GET_METHOD || util.isFormData(data)) {
                    continue;
                }
            }
            request.setRequestHeader(name_1, headers[name_1]);
        }
    }
}
function getResponse(request, _a) {
    var responseType = _a.responseType, status = _a.status;
    var response = request.response;
    if (responseType === JSON_RESPONSE_TYPE) {
        // parse response if not support responseType or response is not object
        if (request.responseType !== JSON_RESPONSE_TYPE &&
            !util.isObject(response)) {
            try {
                response = JSON.parse(request.responseText);
            }
            catch (e) {
                throw e;
            }
        }
    }
    // normalize response
    return {
        data: response,
        status: status
    };
}
function invokeHook(hook, requestResponse, next) {
    next = next || util.noop;
    if (util.isFunction(hook)) {
        hook(requestResponse, function () {
            next(requestResponse);
        });
    }
    else {
        next(requestResponse);
    }
}
function handleReadyStateChange(request, options) {
    var responseType = options.responseType, url = options.url, success = options.success, error = options.error;
    if (request.readyState === 4) {
        var status_1 = normalizeStatus(request.status, { url: url });
        var response = void 0;
        if (util.isResponseOk(status_1)) {
            try {
                response = getResponse(request, { responseType: responseType, status: status_1 });
            }
            catch (e) {
                // json parse error
                return invokeHook(options.beforeError, {
                    request: request,
                    response: response,
                    options: options,
                    error: util_1.createError(e.message, -1 /* XHR_ERROR */)
                }, error);
            }
            invokeHook(options.beforeSuccess, { request: request, response: response, options: options }, success);
        }
        else {
            // network or server error
            invokeHook(options.beforeError, {
                request: request,
                response: response,
                options: options,
                error: util_1.createError('Network Error', -1 /* XHR_ERROR */)
            }, error);
        }
    }
}
/**
 * @ignore
 */
function xhr(options) {
    options = util.merge({
        method: GET_METHOD,
        responseType: JSON_RESPONSE_TYPE,
        withCredentials: true,
        cache: true
    }, options);
    options.method = options.method || GET_METHOD;
    var request = new XMLHttpRequest();
    function send(_a) {
        var request = _a.request, options = _a.options;
        request.send(options.method === GET_METHOD ? null : serialize_1.serialize(options.data));
    }
    function init(_a) {
        var request = _a.request, options = _a.options;
        options.method = options.method.toUpperCase();
        request.open(options.method, normalizeUrl(options.url, options), true);
        request.onreadystatechange = function () {
            handleReadyStateChange(request, options);
        };
        setWithCredentials(request, options);
        setResponseType(request, options);
        setRequestHeader(request, options);
        invokeHook(options.beforeRequest, { request: request, options: options }, send);
    }
    invokeHook(options.configured, { request: request, options: options }, init);
}
exports.default = xhr;
